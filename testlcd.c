/*
 * file: test3threads.c
 */
#include <8051.h>
#include "preemptive.h"
#include "buttonlib.h"
#include "keylib.h"
#include "lcdlib.h"
extern void myTimer0Handler(void); // this functino is define in preemptive.c

__data __at(0x28) char button; // 0x23: current character being generated by Producer1
__data __at(0x29) char keyPad; // 0x23: current character being generated by Producer2

__data __at(0x20) char buffer[3]; // bounded buffer(3-deep)
__data __at(0x23) char head;      // index of next write (producer)
__data __at(0x24) char tail;      // index of next read (consumer)
// At ppt 07 syn examples slide 3 and 4
__data __at(0x25) char mutex; // 0x21:mutual exclusive access
__data __at(0x26) char full;  // 0x22:how many full
__data __at(0x27) char empty; // 0x23:how many empty
__data __at(0x2B) char prev1; 
__data __at(0x2C) char prev2; 
// This producer is going to read from button bank
void Producer1(void)
{

    prev1 = '\0'; // The first character is null
    while (1)         // Loop infinitely
    {
        button = ButtonToChar(); // Read the button
        if ( prev1!= '\0' && button == '\0')
        {
            SemaphoreWait(empty); // Wait until empty is larger than 0, which means at least one buffer slot is available
            SemaphoreWait(mutex); // Wait until mutex is larger than 0, which means we can enter this critical
            // When buffer is being modified, it should be blocked by critical
            // Start Critical
            EA = 0;
            buffer[head] = prev1; // Enqueue the button
            head = (head + 1) % 3;
            EA = 1;                 // End of Critical
            SemaphoreSignal(mutex); // Release mutex ,let other thread use mutex
            SemaphoreSignal(full);  // Because Producer generate one character, so one buffer slot is being used
        }
        prev1 = button;
        
    }
}
// This producer is going to read from keypad
void Producer2(void)
{

    prev2 = '\0'; // The first character is null
    while (1)         // Loop infinitely
    {
        keyPad = KeyToChar(); // Read the keyPad
        
        if (prev2 != '\0' &&  keyPad== '\0')
        {
            SemaphoreWait(empty); // Wait until empty is larger than 0, which means at least one buffer slot is available
            SemaphoreWait(mutex); // Wait until mutex is larger than 0, which means we can enter this critical
            // When buffer and head is being modified, it should be blocked by critical
            // Start Critical
            EA = 0;
            buffer[head] = prev2; // Enqueue the keyPad
            head = (head + 1) % 3;
            EA = 1;                 // End of Critical
            SemaphoreSignal(mutex); // Release mutex ,let other thread use mutex
            SemaphoreSignal(full);  // Because Producer generate one character, so one buffer slot is being used
        }
        prev2 = keyPad;
    }
}
// When buffer is being filled, the consumer will print it
void Consumer(void)
{

    // TMOD |= 0x20; // ppt 08 timer page 17
    // TH1 = (char)-6;
    // SCON = 0x50;
    // TR1 = 1;
    // TI = 0;
    LCD_Init();        // Initialize LCD
    LCD_clearScreen(); // Clear LCD

    while (1) // Infinite loop
    {

        // When LCD is being modified, it should be blocked by critical
        SemaphoreWait(full);   // Wait until full is larger than 0, which means at least one buffer slot is ready to be consumed
        SemaphoreWait(mutex);  // Wait until mutex is larger than 0, which means we can enter this critical
        EA = 0;                // Critical Start
        // char c = ; // Dequeue the character
        
        while (!LCD_ready());              // Wait until LCD is ready, LCD is slow
        LCD_write_char(buffer[tail]); // Write the character to LCD
        tail = (tail + 1) % 3;
        EA = 1;                 // Critical End
        SemaphoreSignal(mutex); // Release mutex ,let other thread use mutex
        SemaphoreSignal(empty); // Because Consumer consumed one character, so one buffer slot is empty
        
    }
}
// This function should be inside main()
void timer0_ISR(void) __interrupt(1)
{
    __asm ljmp _myTimer0Handler
        __endasm;
}

void main(void)
{

    EA = 0;                    // Critical start
    head = 0;                  // Head starts at index 0
    tail = 0;                  // Tail starts at index 0
    SemaphoreCreate(mutex, 1); // 1 means nobody is using they can enter
    SemaphoreCreate(full, 0);  // Non of the buffers is full so is 0
    SemaphoreCreate(empty, 3); // three slots we can use
    Init_Keypad();             // Initialize keypad
    ThreadCreate(Producer1);   // Create producer1 thread
    ThreadCreate(Producer2);   // Create producer2 thread
    Consumer();                // Start consumer (never returns)
    EA = 1;                    // Critical end
}

void _sdcc_gsinit_startup(void)
{
    __asm LJMP _Bootstrap
        __endasm;
}
void _mcs51_genRAMCLEAR(void)
{
}
void _mcs51_genXINIT(void) {}
void _mcs51_genXRAMCLEAR(void) {}